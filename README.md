# Blocks Genetic Algorithm (blocks-ga)

This project implements a genetic algorithm to optimize gameplay for a block placement game. The AI evolves over generations to maximize its score by learning better strategies for placing blocks on a grid.

## Features
- **Genetic Algorithm**: Optimizes block placement strategies using fitness evaluation.
- **Game Simulation**: Simulates gameplay to evaluate chromosomes.
- **Visualizer**: Replays the best game from the evolution process.
- **Customizable Parameters**: Easily adjust population size, mutation rate, and more.

## Requirements
- Python 3.8+
- Required libraries:
  - `pygame`
  - `matplotlib`
  - `numpy`

Install the dependencies using:
```bash
pip install pygame matplotlib numpy
```

## How to Run

### 1. Run the Evolution Process
The main script runs the genetic algorithm and visualizes the results.
```bash
python main.py
```

### 2. Visualize the Evolution & Best Game
After the evolution process, statistics are plotted and the best game is automatically replayed.

## Controls for Visualizer
- **Right Arrow**: Step forward through moves (hold for continuous steps).
- **Left Arrow**: Step backward through moves (hold for continuous steps).
- **Spacebar**: Pause/Unpause the replay.
- **Up Arrow**: Decrease replay delay.
- **Down Arrow**: Increase replay delay.
- **Escape**: Exit the visualizer.

### 3. Play the Game Yourself!
Try to beat the best evolved individual.
```bash
python game.py
```

## Customization
You can modify the following parameters in `main.py`:
- `POPULATION_SIZE`: Number of individuals in each generation.
- `N_GENERATIONS`: Total number of generations.
- `CHROMOSOME_LENGTH`: Length of each chromosome.
- `MUTATION_RATE`: Probability of mutation for each gene.
- `CROSSOVER_RATE`: Probability of crossover between parents.
- `ELITISM_COUNT`: Number of top individuals preserved in each generation.

## Project Structure
```
blocks-ga/
├── game.py              # Core game logic and block shapes
├── genetic_ai.py        # Genetic algorithm implementation
├── simulate.py          # Game simulation for fitness evaluation
├── visualizer.py        # Visualizer for replaying the best game
├── main.py              # Entry point for running the evolution process
└── README.md            # Project documentation
```

## How It Works
1. **Initialization**: A population of random chromosomes is created.
2. **Simulation**: Each chromosome is evaluated by simulating three games The fitness of an individual is the average of the three scores.
3. **Selection**: The best-performing chromosomes are selected as parents.
4. **Crossover and Mutation**: New chromosomes are generated by combining and mutating parents.
5. **Repeat**: Steps 2-4 are repeated for multiple generations.
6. **Visualization**: Game performance improves over time, and the best game is replayed using the visualizer.

## Contributing
Contributions are welcome! Feel free to open issues or submit pull requests to improve the project.